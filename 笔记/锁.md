## 事务的ACID属性

- 原子性（Atomicity）：即不可分割性，事务中的操作要么全不做，要么全做
- 一致性（Consistency）：一个事务在执行前后，数据库都必须处于正确的状态，满足[完整性约束](https://baike.baidu.com/item/数据完整性约束)
- 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行
- 持久性（Durability）：事务处理完成后，对数据的修改就是永久的，即便系统故障也不会丢失

原子性（Atomicity）   

-  事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 
-  回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 

 一致性（Consistency ）   

-  数据是满足完整性约束的 
-  数据在事务的前后，业务整体一致     
  -  举例：转账前后，总金额一致 

 隔离性（Isolation）   

-  一个事务所做的修改在最终提交以前，对其它事务是不可见的。 

 持久性（Durability）   

-  一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。 
-  使用重做日志来保证持久性。

## 事务并发可能出现的情况

#### 脏读（Dirty Read）(T1事务修改某一数据并写回磁盘后，T2读取他，但是T1又回滚撤销了，产生了读脏)

> 一个事务读到了另一个未提交事务修改过的数据

![从根上理解MySQL事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/04/32495/Wcv8DTijTL.png!large)

> 会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现）

#### 不可重复读（Non-Repeatable Read）（验算，发现两次读出结果不一致（update））

> 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）

![从根上理解 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/YdNemia6wc.png!large)

> 会话A开启一个事务，查询id=1的结果，此时查询的结果name为武汉市。接着会话B把id=1的name修改为温州市（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询id=1的结果，读取的结果name为温州市。会话B再此修改id=1的name为杭州市，会话A的事务再次查询id=1，结果name的值为杭州市，这种现象就是不可重复读。

#### 幻读（Phantom）（验算，发现两次读出结果不一致，多了或者消失了（insert）(delete)）

> 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）

![从根上理解 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/04/32495/0sCtxw1Jno.png!large)

> 会话A开启一个事务，查询id>0的记录，此时会查到name=武汉市的记录。接着会话B插入一条name=温州市的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（id>0）再一次查询，此时会出现两条记录（name为武汉市和温州市的记录），这种现象就是幻读。





## 事务的隔离级别

> MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。
>
> MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。
>
> 隔离级别比较：可串行化>可重复读>读已提交>读未提交
>
> 隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交
>
> 由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。

#### 读未提交（READ UNCOMMITTED）

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/iL6jfZxiHJ.png!large)

> 在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。
>
> 可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。

#### 读已提交（READ COMMITTED）

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/BsMcuysaIB.png!large)

> 在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。
>
> 读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。

#### 可重复读（REPEATABLE READ）

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/yjRtVOpMBZ.png!large)

> 在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。
>
> 可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。
>
> 提问：为什么上了写锁（写操作），别的事务还可以读操作？
>
> 因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。

#### 可串行化（SERIALIZABLE）

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/S0Y1nk8yv6.png!large)

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/LIfaeTxwPL.png!large)

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/q4vVuHzqO0.png!large)

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/l1BwLlDlYp.png!large)

> 各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/9Lpt4gaGNi.png!large)

![彻底搞懂 MySQL 事务的隔离级别](https://cdn.learnku.com/uploads/images/202002/05/32495/2yNLgxMBp9.png!large)